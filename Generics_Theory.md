**Generics Theory**


1) В какой версии Java появились параметризованные типы?

**Ответ.** 
Среди новых возможностей после выхода версии Java 1.5, на одном из первых мест стояла поддержка обобщенного программирования, названная в Java generics.

**Источник.** https://rsdn.org/article/java/genericsinjava.xml

2) Приведите 2 примера кода: первый без параметризованного типа; второй - этот же код с параметризованным типом, иллюстрирующий преимущество данного варианта.
   
**Ответ:**
   а) Вот пример кода без применения generic-ов:
   List strList = new ArrayList();
   strList.add("some text");    
   strList.add(new Integer(0)); // ОК, хотя коллекция предназначалась для хранения                              	                                                строк!
   String str = (String)strList.get(0);    
   Integer i = (Integer)strList.get(0); // Ошибка приведения типов во время      	                              	                                                        выполнения (ClassCastException)
   б) А вот код с generic-ами:
   List<String> strList = new ArrayList<String>();
   strList.add("some text");
   strList.add(new Integer());  // сообщение об ошибке компилятора
   String str = strList.get(0);
   Integer i = strList.get(0);  // сообщение об ошибке компилятора
   
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/why.html
   https://rsdn.org/article/java/genericsinjava.xml

3) Какие типы данных запрещены в качестве параметров классов?
   
**Ответ:**
   Отсутствует возможность определить generic примитивным типом
   
**Источник.** http://docs.oracle.com/javase/tutorial/java/generics/types.htm

4) Дан код:
   class Gen <T1, T2 extends Number, T3 extends Object> { … }
   Какие типы можно использовать в качестве аргументов T1, T2, T3?
   
**Ответ.**
   Т1 - Объявление generic-типа в виде <T1>, предполагает использование любого типа в качестве параметра.
   T2 - Такая запись говорит о том, что в качестве типа Т2 разрешено применять только классы, являющиеся подклассами класса Number, в этом случае появляется возможность использовать методы Number со всеми полями и переменными типа Т2.
   T3 - Такая запись говорит о том, что в качестве типа Т3 разрешено применять только классы, являющиеся подклассами класса Object. Т.е. данный случай совпадает с вариантом T1.
   
**Источник.** http://crypto.pp.ua/2010/06/parametrizovannye-klassy-java/
   Блинов И.Н., Романчик В.С. Java. Методы программирования. 2013. Стр.68


5) Дан код:
   class Gen1 <T> { … }
   class Gen2 <T extends Object> { … }
   class Runner {
   private final static Gen1<Object> g11 = new Gen1<>();
   private final static Gen1 g12 = new Gen1();
   private final static Gen2<Object> g21 = new Gen2<>();
   private final static Gen2 g22 = new Gen2();
   ...
   }
   В чем различие объявления классов Gen1 и Gen2?
   Есть ли преимущество в объявлении g11 по сравнению с g12? Обоснуйте ответ.
   Есть ли преимущество в объявлении g21 по сравнению с  g12? Обоснуйте ответ.
   В каком случае используется второй способ (g12, g22)?
   
**Ответ.** а) Объявление класса Gen2 часто используется для поддержки ранних версий кода. В работе программы различий нет.
   б) В первом случае мы имеем дело с дженериком, во втором – с простым типом (raw type). В случае с дженериком, если будет допущена ошибка присваивания несоответствующего типа переменной (или преобразования типа) получим ошибку компиляции, а для простого типа – ошибку времени выполнения (java.lang.ClassCastException). При использовании простых типов, мы теряем преимущество безопасности типов, предоставляемое дженериками.
   в) Аналогично. В первом случае мы имеем дело с дженериком, во втором – с простым типом.
   г) Для поддержки старых версий Java (до версии 1.5).
   
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html
   http://docs.oracle.com/javase/tutorial/extra/generics/convert.html

6) Дан код:
   class SubInfo extends Info { … }
   class Gen1 <T> { … }
   class Gen2 <T extends Info> { … }
1.	Является ли декларация Gen1<Info> подклассом Gen2<Info>?
2.	Является ли декларация Gen1<SubInfo> подклассом Gen1<Info>?
3.	Является ли декларация Gen2<SubInfo> подклассом Gen2<Info>?
      
**Ответ.** 1,2,3 Нет
      
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html

7) Почему нельзя вызвать конструктор generic-типа?
   
**Ответ.**
   Невозможно выполнить явный вызов конструктора generic-типа, т.к. компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта.
   
**Источник.**
   “JAVA. Методы программирования” И. Н. Блинов, В. С. Романчик. 2013г.
   Глава 3, стр. 72

8) Почему нельзя создать generic-поле?
   Почему статический метод не может иметь generic-параметр?
   
**Ответ.**
   Для generic-типов существует ряд ограничений. Например, невозможно выполнить явный вызов конструктора generic-типа, т. к. компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта. По аналогии generic-поля не могут быть статическими, статические методы не могут иметь generic-параметры или обращаться к generic-полям.
   
**Источник.**
   “JAVA. Методы программирования” И. Н. Блинов, В. С. Романчик. 2013г.
   Глава 3, стр. 72

9) Предложите более эффективную запись данного кода:
   <T> void make1(Gen <T extends Object> gen) { … }
   <T, S extends T> void make2(Info<T> info1, Info<S> info2) { … }
   
**Ответ:**
   <T> void make1 (Gen <T> gen) {…}
   <T> void make2 (Info<T> info1, Info<? extends T> info2) {…}

10)Дан код:
class Info {
public <T1> Info() { … }
public <T2> Info(T2 t2) { … }
public <T1> void make1(T1 t1) { … }
public <T3> void make2() { … }
}
Создайте какой-либо экземпляр класса Info
1.	конструктором без аргументов,
2.	конструктором с аргументом.
3.	Синтаксически правильно вызовите методы make1() и make2().
      Ответ:
      Конструктор без аргументов
      Info info = new <Integer> Info();
2.     Конструктор с аргументом
Info info = new Info (new Integer(5));
3.     Вызов методов
                    	info.make1(new Integer());
                    	info.<Integer>make2();
Источник: “JAVA. Методы программирования” И. Н. Блинов, В. С. Романчик. 2013г.
Глава 3, стр. 73.


11) Поясните данный код:
    static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)

Бонусное задание (не обязательное)
Создать статический метод, который возвращает максимальный элемент в массиве объектов ссылочного типа. Если массив пустой, то выбросить исключение.
Привести демо пример использования метода на примере классов
class Product {
private String name;
private Byn price;
...
}
class Purchase {
private Product product;
private int number;
...
}
Найти максимальный элемент в массиве товаров по какому-либо критерию.
Найти максимальный элемент в массиве покупок по критерию - стоимость покупки.

Ограничения:
•	тип Object не использовать,
•	даункасты (преобразования к подклассу) запрещены.

Подсказка
---------------------
Создайте интерфейс, параметризованный информационным классом.
В интерфейсе объявите метод, задающий отношение “выше”.
---------------------

